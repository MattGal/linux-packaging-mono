diff --git a/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/NuGetPackageObject.cs b/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/NuGetPackageObject.cs
index 26f04c1..703a648 100644
--- a/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/NuGetPackageObject.cs
+++ b/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/NuGetPackageObject.cs
@@ -34,6 +34,7 @@ public NuGetPackageObject(string id, string version, Func<string> fullPackagePat
 
         public string Id { get; }
         public string Version { get; }
+        public string RelativePackagePath => (string)LibraryObject["path"];
         
         /// <summary>
         /// The JSON object from the "targets" section in the project.lock.json for this package.
diff --git a/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/ResolveNuGetPackageAssets.cs b/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/ResolveNuGetPackageAssets.cs
index 8acffe3..a074997 100644
--- a/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/ResolveNuGetPackageAssets.cs
+++ b/external/nuget-buildtasks/src/Microsoft.NuGet.Build.Tasks/ResolveNuGetPackageAssets.cs
@@ -369,7 +369,7 @@ private void GetAnalyzers(JObject lockFile)
                         if (Path.GetExtension(file).Equals(".dll", StringComparison.OrdinalIgnoreCase))
                         {
                             string path;
-                            if (TryGetFile(package.Id, package.Version, file, out path))
+                            if (TryGetFile(package.Id, package.Version, package.RelativePackagePath, file, out path))
                             {
                                 var analyzer = new TaskItem(path);
 
@@ -441,16 +441,16 @@ private void SetWinMDMetadata(IEnumerable<ITaskItem> runtimeWinMDs, ICollection<
             }
         }
 
-        private bool TryGetFile(string packageName, string packageVersion, string file, out string path)
+        private bool TryGetFile(string packageName, string packageVersion, string packageRelativePath, string file, out string path)
         {
             if (IsFileValid(file, "C#", "VB"))
             {
-                path = GetPath(packageName, packageVersion, file);
+                path = GetPath(packageName, packageVersion, packageRelativePath, file);
                 return true;
             }
             else if (IsFileValid(file, "VB", "C#"))
             {
-                path = GetPath(packageName, packageVersion, file);
+                path = GetPath(packageName, packageVersion, packageRelativePath, file);
                 return true;
             }
 
@@ -469,9 +469,9 @@ private bool IsFileValid(string file, string expectedLanguage, string unExpected
                             !file.Split('/').Any(x => x.Equals(unExpectedLanguage, StringComparison.OrdinalIgnoreCase)));
         }
 
-        private string GetPath(string packageName, string packageVersion, string file)
+        private string GetPath(string packageId, string packageVersion, string packageRelativePath, string file)
         {
-            return Path.Combine(GetNuGetPackagePath(packageName, packageVersion), file.Replace('/', Path.DirectorySeparatorChar));
+            return Path.Combine(GetNuGetPackagePath(packageId, packageVersion, packageRelativePath), file.Replace('/', Path.DirectorySeparatorChar));
         }
 
         /// <summary>
@@ -932,17 +932,23 @@ private void AddReferencedPackages(JArray packageDependencies, SortedSet<string>
             }
         }
 
-        private string GetNuGetPackagePath(string packageId, string packageVersion)
+        private string GetNuGetPackagePath(string packageId, string packageVersion, string packageRelativePath)
         {
+            string relativePathToUse = String.IsNullOrEmpty(packageRelativePath)
+                                            ? Path.Combine(packageId, packageVersion)
+                                            : packageRelativePath.Replace('/', Path.DirectorySeparatorChar);
+
+            string hashFileName = $"{packageId.ToLowerInvariant()}.{packageVersion.ToLowerInvariant()}.nupkg.sha512";
+
             foreach (var packagesFolder in _packageFolders)
             {
-                string packagePath = Path.Combine(packagesFolder, packageId, packageVersion);
+                string packageFullPath = Path.Combine(packagesFolder, relativePathToUse);
 
                 // The proper way to check if a package is available is to look for the hash file, since that's the last
                 // file written as a part of the restore process. If it's not there, it means something failed part way through.
-                if (_fileExists(Path.Combine(packagePath, $"{packageId}.{packageVersion}.nupkg.sha512")))
+                if (_fileExists(Path.Combine(packageFullPath, hashFileName)))
                 {
-                    return packagePath;
+                    return packageFullPath;
                 }
             }
 
@@ -972,7 +978,7 @@ private IEnumerable<NuGetPackageObject> GetPackagesFromTarget(JObject lockFile,
                 }
                 else
                 {
-                    fullPackagePathGenerator = () => GetNuGetPackagePath(id, version);
+                    fullPackagePathGenerator = () => GetNuGetPackagePath(id, version, (string)libraryObject["path"]);
                 }
 
                 yield return new NuGetPackageObject(id, version, fullPackagePathGenerator, (JObject)package.Value, libraryObject);
